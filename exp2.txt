ğŸ’¥ 1. Demand Paging (FIFO / LRU / OPT)

(Appears in slips: 1, 5, 6, 7, 8, 10, 11, 12, 15, 16, 17, 18, 20)
Concept: Memory management technique that loads pages only when needed.
Algorithm Variants:

FIFO: Replace oldest page.

LRU: Replace least recently used.

OPT: Replace page not used for longest future time.
Key points to say:

Page reference string = given sequence of pages.

Page fault = when page not in memory.

Frame = memory slot for pages.

Output = scheduling order + total page faults.
Explain: â€œI implemented page replacement using X algorithm and calculated total page faults.â€

ğŸ’¥ 2. CPU Scheduling Algorithms

(Appears in slips: 2, 3, 4, 7, 9, 10, 13, 14, 15, 17, 18, 19, 20)
Common types:

FCFS (First Come First Serve): Processes in arrival order.

SJF / Shortest Job First: Least burst time first.

Priority Scheduling: Higher priority first.

Round Robin (RR): Equal time quantum.

Preemptive vs Non-Preemptive: Whether CPU can be taken before completion.
Key terms:

Arrival time, Burst time, Turnaround time, Waiting time, Gantt chart.
Say in viva:
â€œScheduling decides which process runs next. I used (algorithm) to calculate waiting & turnaround time and displayed Gantt chart.â€

ğŸ’¥ 3. Bankerâ€™s Algorithm (Deadlock Avoidance)

(Appears in slips: 1, 4, 5, 9, 13, 19)
Concept: Ensures system remains in a safe state before granting resources.
Steps:

Need = Max - Allocation

Check if request â‰¤ Need and â‰¤ Available.

Find Safe Sequence â†’ no deadlock.
Keywords: Allocation, Max, Need, Available, Safe State.
Say:
â€œI calculated the Need matrix, checked for safety, and printed safe sequence to confirm no deadlock.â€

ğŸ’¥ 4. A* Algorithm (AI Pathfinding)

(Appears in slips: 3, 6, 11, 16)
Concept: Used in AI for shortest or least-cost path finding.
Formula:
f(n) = g(n) + h(n)

g(n) = cost from start to node.

h(n) = heuristic (estimated cost to goal).
Say:
â€œA* uses cost + heuristic to find the optimal path efficiently compared to other search algorithms.â€

ğŸ’¥ 5. AO* Algorithm

(Slip 8)
Concept: Used for AND-OR graphs where solutions combine multiple sub-goals.
Say:
â€œAO* expands nodes based on cost and heuristic values to find a minimal-cost solution in an AND-OR search graph.â€

ğŸ’¥ 6. Process Management & System Calls

(Appears in slips: 1, 2, 3, 4, 5, 7, 9, 10, 11, 13, 15, 19, 20)

ğŸ§© Core Calls:

fork() â†’ Creates child process.

execl() / exec() â†’ Executes new program.

nice() â†’ Changes process priority.

sleep() â†’ Puts process to sleep.

getpid() / getppid() â†’ Process IDs.

orphan process â†’ Parent ends before child.

zombie process â†’ Child ends, parent doesnâ€™t collect status.
Say:
â€œI demonstrated process creation using fork() and managed execution order with sleep() or exec().â€

ğŸ’¥ 7. Clock Function

(Slips: 6, 14, 16)
Concept: Used to measure CPU execution time of code.
Function: clock_t start = clock(); ... clock_t end = clock();
Formula: (end - start) / CLOCKS_PER_SEC
Say:
â€œI used clock() to calculate how long a set of instructions took to execute.â€

ğŸ’¥ 8. Deadlock & Resource Concepts

(Slips: 17, 18, 19)
Deadlock: Processes wait forever due to resource hold and request.
Conditions (4):

Mutual exclusion

Hold and wait

No preemption

Circular wait
Minimum resources to avoid deadlock: Based on allocation and max needs.
Say:
â€œI calculated minimum resources required to keep system in safe state and avoid deadlock.â€

ğŸ’¥ 9. Page Replacement Output to Explain

If examiner asks:
â€œWhat does your output show?â€ â†’
ğŸ‘‰ â€œIt shows page scheduling sequence and total number of page faults using the given algorithm.â€

If CPU scheduling output:
ğŸ‘‰ â€œIt displays Gantt chart, waiting time, turnaround time, and average values.â€


ğŸ§© If Viva asks â€œCompareâ€:
Concept	Meaning
SJF vs FCFS	SJF = min burst time; FCFS = arrival order
Preemptive vs Non-preemptive	CPU can/cannot be taken mid-process
LRU vs FIFO	LRU uses recent use; FIFO uses arrival order
Safe state vs Deadlock	Safe â†’ no deadlock; Deadlock â†’ no safe sequence
Orphan vs Zombie	Orphan = parent dies first; Zombie = child finished, not collected